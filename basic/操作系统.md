# 并发和并行的区别

## 并发（Concurrency）

**定义**：并发是指在**一段时间内**，多个任务可以交替执行的能力。这些任务可能并不是同时执行的，而是通过快速切换（上下文切换）来共享处理器时间，从而给人一种同时执行的错觉。

**特点**：

- **交替执行**：任务在时间上交替执行，而不是同时执行。
- **资源共享**：多个任务共享同一资源（如 `CPU` 时间片）。
- **提高响应性**：通过并发，可以提高系统的响应性，即使在等待 `I/O` 操作或计算密集型任务时，其他任务也可以继续执行。

**应用场景**：

- **Web 服务器**：处理多个客户端请求。
- **操作系统**：管理多个进程和线程。
- **异步编程**：**JavaScript** 的 `Promise` 和 `async/await`。

## 并行（Parallelism）

**定义**：并行是指多个任务在**同一时间点上真正同时执行**的能力。这通常需要多个处理器或多个核心来实现。

**特点**：

- **同时执行**：任务在同一时间点上同时执行。
- **资源独立**：每个任务通常有自己的资源（如 `CPU` 核心）。
- **提高吞吐量**：通过并行处理，可以显著提高系统的吞吐量和性能。

**应用场景**：

- **高性能计算**：科学计算、大数据处理。
- **多核处理器**：利用多核处理器的并行计算能力。
- **GPU 计算**：图形处理单元（`GPU`）的并行计算。

> [!IMPORTANT]
>
> ### 总结
>
> - **并发**：多个任务在一段时间内交替执行，共享资源，提高响应性。
> - **并行**：多个任务在**同一时间点**上真正同时执行，需要多个处理器或核心，提高吞吐量和性能。

# 协程
>
>[!TIP]
> 协程，英文 `Coroutines`，是一种基于线程之上，但又比线程更加轻量级的存在，因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（`Fiber`）。正如一个进程可以拥有多个线程一样，**一个线程也可以拥有多个协程**。具有对内核来说不可见的特性。**为了更高效率的利用线程，而不是频繁的创建线程 销毁线程 以及CPU频繁的切换上下文，不能让线程闲着。**

# 进程的三种状态

进程的状态三种基本状态三种基本状态：**就绪态、执行态、阻塞态**。
这三种基本状态每个 `OS` 中都会有的，因些称为基本态，下面是给出三种基本状态的定义：

- 就绪（`Ready`）状态 通过 `Ready` 我们可以看到，处于此状态的进程已经处于准备好要运行了。 此时进程已经分配好除 `CPU` 外的所有必要资源，只需要获得 `CPU`，便可立即执行。处于就绪态的进程都是在就绪队列中，等待着调度程序的调度（分配 `CPU`）。
- 执行（`Running`）状态 处于此状态的进程是已经获得 `CPU` 且正在执行中。 对于这一状态，在单 `CPU OS` 中，同一时刻只能有一个进程处于此状态，而在多 `CPU OS`，则可以有多个（不超过CPU 的数量）进程同时处于执行状态。
- 阻塞（`Block`）状态 处于此状态的进程是因为在执行的过程中由于发生某种需要等待的事件（`I/O` 请求，申请缓存失败，等待接收数据等），而暂时无法继续运行。在多道批处理系统中，此时需要进程把处理机释放，并选取新的就绪进程执行。与就绪队列相对应的，处于阻塞状态的进程都在阻塞队列中，某些 `OS` 中，出于提高效率的目的，根据阻塞的原因，会有多个阻塞队列。

# 用户态与内核态

## 区别

- **为了区分不同的程序的不同权限**，人们发明了内核态和用户态的概念。
- 用户态和内核态是操作系统的两种运行级别，两者最大的区别就是**特权级不同**。用户态拥有最低的特权级，内核态拥有较高的特权级。 运行在用户态的程序不能直接访问操作系统内核数据结构和程序。
- 内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。

## 状态转换

### 通过系统调用进行切换

- 当应用程序在用户态下执行到需要内核提供服务的操作时，如文件读写、进程创建、网络通信等，会执行一条特定的系统调用指令来发起系统调用。
- 这条指令会导致处理器产生一个软中断，从而触发从**用户态到内核态**的切换。处理器会根据预先设定的中断向量表或系统调用表，找到对应的内核系统调用处理程序的入口地址，并将程序的执行流程转移到该入口地址，进入内核态。
- 当内核完成系统调用的处理后，会通过执行一条特定的指令将处理器的执行模式从内核态切换回用户态。在返回之前，内核会将系统调用的结果按照约定的方式放置在寄存器或内存中，以便应用程序能够获取到系统调用的返回值。
- 同时，内核会从内核栈中恢复之前保存的用户态上下文信息，包括程序计数器、处理器状态字、通用寄存器、栈指针等，使处理器能够继续在用户态下执行应用程序的后续指令，就好像系统调用从未发生过一样，实现了用户态和内核态之间的无缝切换。

### 异常处理引发的切换

- 当处理器在用户态下执行指令时，如果发生了异常情况，如页面故障、算术溢出、非法指令等，处理器会自动从用户态切换到内核态，将执行流程转移到内核中的相应异常处理程序。
- 与系统调用类似，处理器会在切换时保存当前用户态的上下文信息到内核栈中，然后由内核的异常处理程序对异常进行处理。异常处理程序会根据异常的类型采取相应的措施，如进行页面置换、处理算术错误、终止违规程序等。处理完成后，再从内核栈中恢复用户态上下文信息，返回用户态继续执行程序，或者根据异常的严重程度采取更严厉的措施，如终止整个进程。

### 中断处理引发的切换

- 当处理器接收到外部中断信号时，如定时器中断、键盘中断、网络中断等，也会从用户态切换到内核态，执行内核中的中断处理程序。中断处理程序的主要任务是及时响应中断事件，进行相应的处理，如更新系统时钟、处理键盘输入、接收网络数据包等。
- 在中断发生时，处理器同样会保存当前用户态的上下文信息到内核栈中，然后进入内核态执行中断处理程序。中断处理完成后，再恢复用户态上下文信息，返回用户态继续执行被中断的程序。需要注意的是，中断的发生是异步的，可能会在任何时候打断用户态程序的执行，因此中断处理程序需要尽可能快速地完成处理，以减少对用户态程序执行的影响。
